// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Entity = (function() {

    function Entity(x, y, color) {
      this.x = x;
      this.y = y;
      this.color = color;
    }

    Entity.prototype.update = function() {};

    Entity.prototype.draw = function(canvas) {};

    return Entity;

  })();

  window.RectEntity = (function(_super) {

    __extends(RectEntity, _super);

    function RectEntity(x, y, color, width, height) {
      this.width = width;
      this.height = height;
      RectEntity.__super__.constructor.call(this, x, y, color);
    }

    return RectEntity;

  })(Entity);

  window.Obstacle = (function(_super) {

    __extends(Obstacle, _super);

    function Obstacle(x, y, color, parent) {
      this.parent = parent;
      Obstacle.__super__.constructor.call(this, x, y, color, 30, 30);
    }

    Obstacle.prototype.checkCollision = function() {
      var player;
      player = this.parent.player;
      return !((player.x > this.x + this.width) || (player.x + player.width < this.x) || (player.y > this.y + this.height) || (player.y + player.height < this.y));
    };

    Obstacle.prototype.update = function() {
      if (this.checkCollision()) {
        this.parent.player.dead = true;
      }
      return this.x -= g.lateral;
    };

    Obstacle.prototype.draw = function(canvas) {
      return canvas.drawFill(this);
    };

    return Obstacle;

  })(RectEntity);

  window.Player = (function(_super) {

    __extends(Player, _super);

    function Player(x, y, color, parent) {
      this.parent = parent;
      this.acceleration = 0;
      this.boost = -30;
      this.gap = 500;
      this.lastBeat = 0;
      this.firstBeat = false;
      this.dead = false;
      Player.__super__.constructor.call(this, x, y, color, 30, 30);
    }

    Player.prototype.update = function() {
      var input;
      input = g.input;
      this.acceleration += g.gravity * g.sFrac;
      if (this.parent.inputBool) {
        this.acceleration += this.boost * g.sFrac;
      }
      if (this.acceleration <= -5.5) {
        this.acceleration = -5.5;
      }
      return this.y += this.acceleration;
    };

    Player.prototype.draw = function(canvas) {
      return canvas.drawFill(this);
    };

    return Player;

  })(RectEntity);

  window.Pickup = (function(_super) {

    __extends(Pickup, _super);

    function Pickup(x, y, type, parent) {
      var color;
      this.type = type;
      this.parent = parent;
      switch (this.type) {
        case 0:
          color = '#ff00ff';
          break;
        case 1:
          color = '#800080';
          break;
        case 2:
          color = '#ffff00';
          break;
        default:
          console.log('invalid pickup type');
      }
      Pickup.__super__.constructor.call(this, x, y, color, g.entityDim, g.entityDim);
      this.collected = false;
    }

    Pickup.prototype.checkCollision = function() {
      var player;
      player = this.parent.player;
      return !((player.x > this.x + this.width) || (player.x + player.width < this.x) || (player.y > this.y + this.height) || (player.y + player.height < this.y));
    };

    Pickup.prototype.changeType = function(type) {
      this.type = type;
      switch (this.type) {
        case 0:
          return this.color = '#ff00ff';
        case 1:
          return this.color = '#800080';
        case 2:
          return this.color = '#ffff00';
        default:
          return console.log('invalid pickup type');
      }
    };

    Pickup.prototype.update = function() {
      if (this.checkCollision()) {
        return this.collected = true;
      }
    };

    Pickup.prototype.draw = function(canvas) {
      return canvas.drawFill(this);
    };

    return Pickup;

  })(RectEntity);

  window.Wall = (function() {

    function Wall(pos, color, parent) {
      var count, i, _i, _ref;
      this.pos = pos;
      this.parent = parent;
      this.entities = [];
      count = Math.ceil((g.width * 1.5) / g.entityDim);
      for (i = _i = 0, _ref = count + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.entities.push(new Obstacle(g.entityDim * i, this.pos, color, this.parent));
      }
    }

    Wall.prototype.update = function() {
      var end, entity, first, last, _i, _len, _ref, _results;
      first = this.entities[0];
      if (first.x + first.width < -(g.width / 2)) {
        this.entities.removeIndex(0);
        end = this.entities.last();
        last = new Obstacle(end.x + g.entityDim, this.pos, end.color, this.parent);
        this.entities.push(last);
      }
      _ref = this.entities;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        _results.push(entity.update());
      }
      return _results;
    };

    Wall.prototype.draw = function(canvas) {
      var entity, _i, _len, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        _results.push(entity.draw(canvas));
      }
      return _results;
    };

    return Wall;

  })();

}).call(this);
